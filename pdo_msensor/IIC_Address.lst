C51 COMPILER V9.60.0.0   IIC_ADDRESS                                                       10/14/2021 23:05:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IIC_ADDRESS
OBJECT MODULE PLACED IN .\output\IIC_Address.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE library\IIC_Address.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\library;..\LSM9D
                    -S1_new sensor MCU program) DEFINE(Custom,library) DEBUG OBJECTEXTEND PRINT(.\IIC_Address.lst) TABS(2) OBJECT(.\output\II
                    -C_Address.obj)

line level    source

   1          #include <AT89X52.h>
   2          #include <INTRINS.H>
   3          
   4          #include "IIC_Address.h"
   5          #include "Ext_function.h"
   6          
   7          //char* sensor_type_name;
   8          
   9          void SetI2CParameters(void)
  10          {
  11   1        
  12   1        
  13   1        if (StringCompare(sensor_type_name, "LSM9DS1", 7) == 1)
*** WARNING C182 IN LINE 13 OF library\IIC_Address.c: pointer to different objects
  14   1        {
  15   2          ADD_I2C = 0x38;   //Magnet I2C control address 0x38 0011 1000 (Deven)
  16   2          //ADD_I2C = 0x3C;   //BlueBoard
  17   2          ADD_X_LSB = 0x28;    //mag Xout LSB
  18   2          ADD_X_MSB = 0x29;    //mag Xout MSB
  19   2          ADD_Y_LSB = 0x2A;    //mag Yout LSB
  20   2          ADD_Y_MSB = 0x2B;    //mag Yout MSB
  21   2          ADD_Z_LSB = 0x2C;    //mag Zout LSB
  22   2          ADD_Z_MSB = 0x2D;    //mag Zout MSB
  23   2          ADD_STATUS = 0x27;     //mag Device status
  24   2          CTRL_REG1_M = 0x20; //Control register 1 >> ODR select
  25   2          CTRL_REG2_M = 0x21; //Control register 2 >> gauss full-scale &  reset Configuration registers and user r
             -egister
  26   2          CTRL_REG3_M = 0x22; //Control register 3 >> continue/single mode
  27   2          CTRL_REG4_M = 0x23; //Control register 4 >> mag Z operation mode 
  28   2          CTRL_REG5_M = 0x24; //Control register 5 >> block data updata
  29   2          ADD_ID = 0x0F;       //Product ID 0b0011 1101 >> 0x3D
  30   2      
  31   2          ACGY_ADD_I2C = 0xD4;      //Acc & Gyro I2C control address 0xD4 1101 0100 (Deven)
  32   2          //ACGY_ADD_I2C = 0xD6; //Blue Board
  33   2          ACGY_GYR_ADD_X_LSB = 0x18;   //gyro Xout LSB
  34   2          ACGY_GYR_ADD_X_MSB = 0x19;   //gyro Xout MSB
  35   2          ACGY_GYR_ADD_Y_LSB = 0x1A;   //gyro Yout LSB
  36   2          ACGY_GYR_ADD_Y_MSB = 0x1B;   //gyro Yout MSB
  37   2          ACGY_GYR_ADD_Z_LSB = 0x1C;   //gyro Zout LSB
  38   2          ACGY_GYR_ADD_Z_MSB = 0x1D;   //gyro Zout MSB
  39   2          ACGY_ADD_STATUS = 0x17;    //Device status>> bit5:Temp, bit6:Gyro, bit7:Acc
  40   2          ACGY_ADD_TMP_LSB = 0x15;  //Temperature Output LSB Register  Read
  41   2          ACGY_ADD_TMP_MSB = 0x16;  //Temperature Output MSB Register  Read
  42   2          ACGY_CTRL_REG1_G = 0x10;   //Control Register1 >> Gyro full-scale, ODR, BW 
  43   2          ACGY_ORIENT_CFG_G = 0x13;   //Gyro XYZ sign 
  44   2          ACGY_CTRL_REG4 = 0x1E; //Control Register4 >> GYRO XYZ enable
  45   2          ACGY_CTRL_REG5 = 0x1F; //Control Register5 >> ACC XYZ enable
  46   2          ACGY_CTRL_REG6 = 0x20; //Control Register6 >> ACC full-scale, ODR, BW
  47   2          ACGY_CTRL_REG7 = 0x21; //Control Register7 >>ACC high resolution mode
  48   2          ACGY_CTRL_REG8 = 0x22;  //Control Register8 >> Softreset â†’ claer by hardware
  49   2          ACGY_CTRL_REG9 = 0x23;  //Control Register9 >> FIFO enable
  50   2          ACGY_FIFO_CTRL = 0x2E;  //FIFO mode select
  51   2          ACGY_ACC_ADD_X_LSB = 0x28; //Acc Xout LSB
C51 COMPILER V9.60.0.0   IIC_ADDRESS                                                       10/14/2021 23:05:14 PAGE 2   

  52   2          ACGY_ACC_ADD_X_MSB = 0x29; //Acc Xout MSB
  53   2          ACGY_ACC_ADD_Y_LSB = 0x2A; //Acc Yout LSB
  54   2          ACGY_ACC_ADD_Y_MSB = 0x2B; //Acc Yout MSB
  55   2          ACGY_ACC_ADD_Z_LSB = 0x2C; //Acc Zout LSB
  56   2          ACGY_ACC_ADD_Z_MSB = 0x2D; //Acc Zout MSB
  57   2          ACGY_ADD_ID = 0x0F;   //Product ID 0b01101000 >> 0x68
  58   2          
  59   2        }
  60   1        /*
  61   1        if (StringCompare(sensor_type_name, "MMC5883MA", 9) == 1)
  62   1        {
  63   1          ADD_I2C = 0x60;    //I2C control address 0x60 0110 0000
  64   1          ADD_X_LSB = 0x00;  //Xout LSB
  65   1          ADD_X_MSB = 0x01;  //Xout MSB
  66   1          ADD_Y_LSB = 0x02;  //Yout LSB
  67   1          ADD_Y_MSB = 0x03;  //Yout MSB
  68   1          ADD_Z_LSB = 0x04;  //Zout LSB
  69   1          ADD_Z_MSB = 0x05;  //Zout MSB
  70   1          ADD_TMP_MSB = 0x06;  //Temperature output
  71   1          ADD_STATUS = 0x07;   //Device status
  72   1          ADD_CONFIG_0 = 0x08; //Control register 0
  73   1          ADD_CONFIG_1 = 0x09; //Control register 1
  74   1          ADD_CONFIG_2 = 0x0A; //Control register 2
  75   1          //ADD_X_THR = 0x0B;  //Motion detection threshold of X
  76   1          //ADD_Y_THR = 0x0C;  //Motion detection threshold of Y
  77   1          //ADD_Z_THR = 0x0D;  //Motion detection threshold of Z
  78   1          ADD_ID = 0x2F; //Product ID 0b0010 1111
  79   1        }
  80   1        */
  81   1        // else if (StringCompare(sensor_type_name, "HMC5983", 7) == 1)
  82   1        // {
  83   1        //  ADD_I2C = 0x3C;    //I2C control address
  84   1        //  ADD_CONFIG_A = 0x00; //Configuration Register A   Read/Write
  85   1        //  ADD_CONFIG_B = 0x01; //Configuration Register B   Read/Write
  86   1        //  ADD_MODE = 0x02;   //Mode Register  Read/Write
  87   1        //  ADD_X_MSB = 0x03;  //Data Output X MSB Register  Read
  88   1        //  ADD_X_LSB = 0x04;  //Data Output X LSB Register  Read
  89   1        //  ADD_Z_MSB = 0x05;  //Data Output Z MSB Register  Read
  90   1        //  ADD_Z_LSB = 0x06;  //Data Output Z LSB Register  Read
  91   1        //  ADD_Y_MSB = 0x07;  //Data Output Y MSB Register  Read
  92   1        //  ADD_Y_LSB = 0x08;  //Data Output Y LSB Register  Read
  93   1        //  ADD_STATUS = 0x09;   //Status Register  Read
  94   1        //  ADD_ID_A = 0x0A;   //Identification Register A  Read
  95   1        //  ADD_ID_B = 0x0B;   //Identification Register B  Read
  96   1        //  ADD_ID_C = 0x0C;   //Identification Register C  Read
  97   1        //  ADD_TMP_MSB = 0x31;  //Temperature Output MSB Register  Read
  98   1        //  ADD_TMP_LSB = 0x32;  //Temperature Output LSB Register  Read
  99   1        // }
 100   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    187    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
